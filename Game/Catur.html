<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Game Catur - Single File</title>
  <style>
    :root{ --board-size: 640px; --square-size: calc(var(--board-size)/8);} 
    body{ font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin:0; display:flex; height:100vh; align-items:center; justify-content:center; background:linear-gradient(180deg,#e9eef8,#f7fbff);} 
    .container{ display:flex; gap:20px; align-items:flex-start;}
    .board{ width:min(90vmin, var(--board-size)); height:min(90vmin, var(--board-size)); display:grid; grid-template-columns:repeat(8,1fr); box-shadow:0 8px 30px rgba(10,20,40,0.12); border-radius:12px; overflow:hidden; }
    .square{ width:100%; aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; font-size:calc(var(--square-size) * 0.6); user-select:none; cursor:pointer; position:relative; }
    .square.light{ background:#f0d9b5; }
    .square.dark{ background:#b58863; }
    .square.highlight { outline: 4px solid rgba(255,255,0,0.45); box-sizing:border-box; }
    .square.move { box-shadow: inset 0 0 0 6px rgba(0,0,0,0.06); }
    .piece{ pointer-events:none; }
    .right-panel{ width:260px; display:flex; flex-direction:column; gap:12px; }
    .card{ background:white; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(10,20,40,0.06); }
    .btn{ display:inline-block; width:100%; padding:10px; border-radius:8px; text-align:center; text-decoration:none; font-weight:600; cursor:pointer; }
    .btn.primary{ background:#2563eb; color:white; }
    .btn.ghost{ background:transparent; border:1px solid #d1d5db; color:#111827; }
    .status{ font-weight:700; font-size:14px; }
    .small{ font-size:13px; color:#374151; }
    .moves-list{ max-height:200px; overflow:auto; padding:6px; border-radius:6px; background:linear-gradient(180deg,#fbfdff,#f5f8ff);} 
    footer.note{ font-size:12px; color:#6b7280; margin-top:6px; }
  </style>
</head>
<body>
  <div class="container">
    <div>
      <div id="board" class="board"></div>
    </div>

    <div class="right-panel">
      <div class="card">
        <div class="status">Giliran: <span id="turn">Putih</span></div>
        <div class="small">Klik kotak untuk pilih bidak, klik lagi untuk pindah.</div>
      </div>

      <div class="card">
        <div style="display:flex;gap:8px;margin-bottom:8px;">
          <button id="undo" class="btn ghost">Undo</button>
          <button id="restart" class="btn ghost">Restart</button>
        </div>
        <div class="small">Langkah terakhir:</div>
        <div id="last-move" class="small" style="min-height:22px"></div>
      </div>

      <div class="card">
        <div class="small">Log langkah:</div>
        <div id="moves" class="moves-list"></div>
      </div>

      <div class="card">
        <!-- User will replace the href with their site link later -->
        <a id="home-link" class="btn primary" href="homegame.html">Kembali ke Halaman Utama</a>
      </div>

      <div class="card">
        <div class="small">Catatan:</div>
        <ul class="small" style="margin:8px 0 0 16px;padding:0;">
          <li>Promosi pion otomatis jadi menteri (queen).</li>
          <li>Tidak ada en passant atau rokade untuk kesederhanaan.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    // Simple chess implementation (playable). For clarity and brevity:
    // - Supports: pawn (including double-step), rook, knight, bishop, queen, king
    // - Supports promotion (to queen)
    // - Does NOT implement en passant or castling
    // - Basic check prevention: illegal moves that leave own king in check are blocked

    const boardEl = document.getElementById('board');
    const turnEl = document.getElementById('turn');
    const movesEl = document.getElementById('moves');
    const lastMoveEl = document.getElementById('last-move');
    const restartBtn = document.getElementById('restart');
    const undoBtn = document.getElementById('undo');

    // Unicode pieces (white/black)
    const UNICODE = {
      p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚',
      P: '♙', R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔'
    };

    // Board state: 8x8 array, rows 0..7 (0 is rank 8), cols 0..7 (0 is file a)
    let state = null; // will be 2D array of piece chars or null
    let history = [];
    let selected = null; // {r,c}
    let legalMoves = [];
    let turn = 'w'; // 'w' or 'b'

    function initBoard() {
      // Standard starting position
      const rows = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
      ];
      state = rows.map(r=>r.slice());
      history = [];
      selected = null; legalMoves = [];
      turn = 'w';
      render();
      updateUI();
    }

    function render(){
      boardEl.innerHTML = '';
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq = document.createElement('div');
          sq.className = 'square ' + (((r+c)%2===0)?'light':'dark');
          sq.dataset.r = r; sq.dataset.c = c;
          sq.addEventListener('click', onSquareClick);
          const piece = state[r][c];
          if(piece){
            const p = document.createElement('div');
            p.className='piece'; p.textContent = UNICODE[piece] || piece;
            sq.appendChild(p);
          }
          // highlight selected
          if(selected && selected.r==r && selected.c==c) sq.classList.add('highlight');
          // highlight legal moves
          if(legalMoves.some(m=>m.r==r && m.c==c)) sq.classList.add('move');

          boardEl.appendChild(sq);
        }
      }
    }

    function onSquareClick(e){
      const r = +e.currentTarget.dataset.r;
      const c = +e.currentTarget.dataset.c;
      const piece = state[r][c];

      if(selected){
        // If clicked a legal move -> move
        const move = legalMoves.find(m=>m.r==r && m.c==c);
        if(move){
          makeMove(selected.r, selected.c, r, c, move);
          selected = null; legalMoves = [];
          render(); updateUI();
          return;
        }
      }

      // Otherwise try to select if piece of current player's color
      if(piece && pieceColor(piece)===turn){
        selected = {r,c};
        legalMoves = generateLegalMoves(r,c);
        render();
      } else {
        // clicked empty or enemy piece but not legal -> clear selection
        selected = null; legalMoves = [];
        render();
      }
    }

    function pieceColor(p){
      if(!p) return null;
      return (p === p.toUpperCase()) ? 'w' : 'b';
    }

    function cloneState(s){ return s.map(r=>r.slice()); }

    function makeMove(sr,sc, tr,tc, moveMeta){
      const sBefore = cloneState(state);
      const piece = state[sr][sc];
      const captured = state[tr][tc];
      state[tr][tc] = piece;
      state[sr][sc] = null;

      // pawn promotion
      if(piece==='P' && tr===0){ state[tr][tc] = 'Q'; }
      if(piece==='p' && tr===7){ state[tr][tc] = 'q'; }

      history.push({before:sBefore, from:[sr,sc], to:[tr,tc], piece, captured});
      // switch turn
      turn = (turn==='w')? 'b':'w';

      // record move in SAN-ish (very simple)
      const san = sanFromMove(piece, sr,sc, tr,tc, captured);
      prependMoveLog(san);
      lastMoveEl.textContent = san;

      // if next player has no legal moves -> checkmate/stalemate
      const anyLegal = anyLegalMoveFor(turn);
      if(!anyLegal){
        const kingInCheck = isKingInCheck(turn);
        if(kingInCheck){
          alert((turn==='w'?'Putih':'Hitam') + ' sedang skak dan tidak bisa bergerak — Mate!');
        } else {
          alert('Remis — tidak ada langkah legal.');
        }
      }
    }

    function sanFromMove(piece,sr,sc,tr,tc,captured){
      const files = 'abcdefgh';
      const ranks = '87654321';
      const from = files[sc]+ranks[sr];
      const to = files[tc]+ranks[tr];
      const p = piece.toUpperCase();
      const isPawn = (p==='P');
      let out = isPawn? from + (captured? 'x':'-') + to : p + (captured? 'x':'-') + to;
      return out;
    }

    function prependMoveLog(san){
      const div = document.createElement('div'); div.textContent = san; movesEl.prepend(div);
    }

    function anyLegalMoveFor(color){
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const p = state[r][c]; if(!p) continue;
        if(pieceColor(p)!==color) continue;
        const moves = generateLegalMoves(r,c);
        if(moves.length) return true;
      }
      return false;
    }

    function generateLegalMoves(r,c){
      const p = state[r][c]; if(!p) return [];
      const color = pieceColor(p);
      let raw = generateRawMoves(r,c,p);
      // filter out moves that leave own king in check
      const legal = raw.filter(m=>{
        const sim = cloneState(state);
        sim[m.r][m.c] = sim[r][c]; sim[r][c] = null;
        // promotion simple: if pawn reaches last rank, make queen
        if(sim[m.r][m.c] === 'P' && m.r===0) sim[m.r][m.c] = 'Q';
        if(sim[m.r][m.c] === 'p' && m.r===7) sim[m.r][m.c] = 'q';
        return !isKingInCheck(color, sim);
      });
      return legal;
    }

    function isKingInCheck(color, boardState=null){
      const s = boardState || state;
      let kr=-1,kc=-1;
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const p = s[r][c]; if(!p) continue;
        if((p==='K' && color==='w') || (p==='k' && color==='b')){ kr=r; kc=c; }
      }
      if(kr<0) return false; // should not happen
      // check if any enemy piece attacks kr,kc
      const enemy = (color==='w')? 'b':'w';
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const p = s[r][c]; if(!p) continue; if(pieceColor(p)!==enemy) continue;
        const attacks = generateRawMoves(r,c,p,s,true); // attack-only mode where pawns attack diagonally
        if(attacks.some(a=>a.r===kr && a.c===kc)) return true;
      }
      return false;
    }

    // generate raw moves for piece at r,c on board s (optional). If attackOnly true, pawns only produce capture squares
    function generateRawMoves(r,c,p, s=null, attackOnly=false){
      const board = s || state;
      const color = pieceColor(p);
      const moves = [];
      const dir = (color==='w')? -1 : 1; // pawns move up for white (r decreases)

      function inBounds(rr,cc){ return rr>=0 && rr<8 && cc>=0 && cc<8; }
      function isEmpty(rr,cc){ return inBounds(rr,cc) && !board[rr][cc]; }
      function isEnemy(rr,cc){ return inBounds(rr,cc) && board[rr][cc] && pieceColor(board[rr][cc])!==color; }

      const up = (rr,cc)=>inBounds(rr,cc) && !board[rr][cc];

      const t = p.toUpperCase();
      if(t==='P'){
        // pawn
        const oneR = r + dir;
        if(!attackOnly){ if(inBounds(oneR,c) && !board[oneR][c]){ moves.push({r:oneR,c});
            // double from initial rank
            const startRank = (color==='w')? 6 : 1;
            const twoR = r + dir*2;
            if(r===startRank && inBounds(twoR,c) && !board[twoR][c]) moves.push({r:twoR,c});
          }
        }
        // captures
        for(const dc of [-1,1]){
          const rr = r+dir, cc = c+dc;
          if(inBounds(rr,cc) && board[rr][cc] && pieceColor(board[rr][cc])!==color) moves.push({r:rr,c:cc});
        }
        return moves;
      }

      if(t==='N'){
        const del = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for(const d of del){ const rr=r+d[0], cc=c+d[1]; if(inBounds(rr,cc) && (!board[rr][cc] || pieceColor(board[rr][cc])!==color)) moves.push({r:rr,c:cc}); }
        return moves;
      }

      if(t==='B' || t==='R' || t==='Q'){
        const dirs = [];
        if(t==='B' || t==='Q') dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
        if(t==='R' || t==='Q') dirs.push([-1,0],[1,0],[0,-1],[0,1]);
        for(const d of dirs){
          let rr=r+d[0], cc=c+d[1];
          while(inBounds(rr,cc)){
            if(!board[rr][cc]){ moves.push({r:rr,c:cc}); }
            else{ if(pieceColor(board[rr][cc])!==color) moves.push({r:rr,c:cc}); break; }
            rr+=d[0]; cc+=d[1];
          }
        }
        return moves;
      }

      if(t==='K'){
        for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
          if(dr===0 && dc===0) continue; const rr=r+dr, cc=c+dc; if(inBounds(rr,cc) && (!board[rr][cc] || pieceColor(board[rr][cc])!==color)) moves.push({r:rr,c:cc});
        }
        // Note: no castling implemented
        return moves;
      }

      return moves;
    }

    // UI helpers
    function updateUI(){
      turnEl.textContent = (turn==='w')? 'Putih' : 'Hitam';
    }

    restartBtn.addEventListener('click', ()=>{ if(confirm('Mulai ulang permainan?')) initBoard(); });
    undoBtn.addEventListener('click', ()=>{ if(history.length===0) return; const last = history.pop(); state = cloneState(last.before); turn = (turn==='w')? 'b':'w'; render(); updateUI(); movesEl.firstChild && movesEl.removeChild(movesEl.firstChild); lastMoveEl.textContent=''; });

    // initialize
    initBoard();

    // expose for debugging (optional)
    window._chess = { state, initBoard };
  </script>
</body>
</html>
